###### Sort Algorithms ######
I. Basic Sort
 - https://www.geeksforgeeks.org/dsa/introduction-to-sorting-algorithm/
 1. In Place Sorting _ sắp xếp tại chỗ:
  + Không tạo ra thêm bản sao hay mảng phụ, thay đổi trực tiếp dữ liệu ngay trên mảng gốc, chỉ dùng một lượng bộ nhớ (constant space) để tạo ra kết quả.
  + Ví dụ: selection sort, bubble sort, insertion sort, heap sort.
 2. Internal Sorting _ sắp xếp nội bộ:
  + Sắp xếp khi toàn bộ dữ liệu cần sắp xếp đều được lưu trữ trong bộ nhớ chính (main memory)
  + Toàn bộ dữ liệu truy cập trực tiếp trong ram, không cần đọc ghi thường xuyên từ bộ nhớ ngoài\
  - Đặc điểm: dữ liệu nhỏ nếu vượt quá dung lượng bộ nhớ chính, Internal sorting không thể thực hiện được.
              nhanh, không có độ trễ do I/O.
  + ví dụ: selection sort, insertion sort, quick sort, merge sort.
 3. External sorting _ sắp xếp ngoài bộ:
  + Dùng để sắp xếp dữ liệu lớn, vượt qua không gian bộ nhớ chính (main memory), buộc phải lưu trữ và xử lý một phần trong bộ nhớ phụ.
 4. Stable sorting _ sắp xếp ổn định:
  + Một thuật toán sắp xếp ổn định (stable sorting algorithm) là thuật toán mà nếu hai phần tử có khóa bằng nhau, thì thứ tự của chúng trong kết quả sắp xếp giống với thứ tự trong dữ liệu ban đầu.
  + khi ta có các cặp key–value.
  + Đối với số nguyên không cần tính ổn định
  + Tính ổn định giữ nguyên các giá trị bằng nhau khi sắp xếp - đặc biệt qua trọng khi dữ liệu có nhiều khóa trùng nhau hoặc cần sắp xếp nhiều lần theo các tiêu chí khác nhau.
  + Ví dụ: bubble sort, insertion sort, merge sort, couting sort, radix sort.
  + selection sort - có thể ổn định nếu xét chỉ số.
  + quick sort, heap sort - mặc định không ổn định
 5. Hybrid sort:
  + Kết hợp các thuật toán sắp xếp với nhau.
  + tim sort: sử dụng merge sort - insertion sort
  + introSort: sử dụng quick sort, heap sort, insertion sort
II. Type of sorting techniques.
 1. Comparision - based: dựa trên so sánh
  - Là loại thuật toán sắp xếp dựa trên việc so sánh các phần tử với nhau để xác định thứ tự.
  - Thuật toán liên tục so sánh hai phần tử và hoán đổi vị trí của chúng nếu cần, cho đến khi toàn bộ mảng được sắp xếp.
  - Ví dụ: Bubble Sort, Insertion Sort, Selection Sort, Merge Sort, Quick Sort, Heap Sort.
  - Time complexity: O(nlogn)
 2. Non comparision - based: không dựa trên so sánh.
  - Là loại thuật toán sắp xếp không dùng phép so sánh trực tiếp giữa các phần tử.
  - dựa vào đặc tính của dữ liệu (ví dụ: giá trị số nguyên, chữ cái, phạm vi giá trị, v.v.) để xác định vị trí của phần tử.
  - Thường dùng đếm, phân loại, hoặc sắp xếp theo từng chữ số (digit) thay vì so sánh trực tiếp.
  - Ví dụ: Counting sort, bucket sort, radix sort.
  - Time complexity: O(n)
III. Sort Algorithms
 1. Selection Sort Algorithms: 
  - Ý tưởng:
  + Tìm phần tử nhỏ nhất trong toàn bộ mảng.
  + Hoán đổi phần tử nhỏ nhất đó với phần tử đầu tiên của mảng. → Khi đó, phần tử đầu tiên đã ở đúng vị trí cuối cùng của nó trong mảng đã sắp xếp.
  + Tìm phần tử nhỏ nhất trong phần còn lại của mảng (bắt đầu từ vị trí thứ 2), rồi hoán đổi nó với phần tử thứ hai.
  + Tiếp tục quá trình cho đến khi toàn bộ mảng được sắp xếp.
  - Đặc điểm:
   + In Place: sắp xếp tại chỗ.
   + Kiểu sắp xếp: Comparison - based
   + Cách hoạt động: chọn phần tử nhỏ nhất rồi hoán đổi
   + Time complexity: 
    best: O(n^2)
    worst: O(n^2)
    avg: O(n^2)
   + Ổn định: ko
   + Ưu điểm: dễ hiểu, dễ cài đặt
   + Nhược điểm: chậm với mảng lớn.
  2. Bubble Sort Algorithms:
   - Ý tưởng:
   + So sánh hai phần tử liền kề nhau, duyệt qua nhiều lần và phần tử lớn sẽ được di chuyển đến phần tử cuối cùng.
   + Hoán đổi phần tử lớn hơn đứng trước phần tử nhỏ hơn.
   - Đặc điểm:
   + In Place: có
   + Time complexity:
    best: O(n)
    worst: O(n^2)
    avg: O(n^2)
   + Ổn định: có
   + Ưu điểm: dễ hiểu, dễ cài đặt
   + Nhược điểm: chậm với mảng lớn.
  3. Insert Sort Algorithms:
   - Ý tưởng:
   + Chia làm hai phần: phần được sắp xếp và phần chưa được sắp xếp, mỗi lần lặp lấy một phần tử từ phần chưa sắp xếp chèn nó đúng vào vị trí trong phần đã sắp xếp
   + Hoạt động:
    . Bắt đầu từ phần tử thứ 2, vì phần tử đầu tiên mặc định là sắp xếp
    . So sánh phần tử hiện tại với các phần tử trước đó, nếu nhỏ hơn dịch tất cả các phần tử sang phải đê tạo chỗ trống
    . Chèn phần tử vào đúng ví trí
    . lặp lại cho đến khi toàn bộ mảng được sắp xếp
   - Đặc điểm:
   + Time complexity: 
     Best: O(n)
     Worst: O(n^2)
     Agv: O(n^2)
   + In place: có
   + Là giải thuật ổn định (stable sort).
   + Hiệu quả với danh sách nhỏ hoặc gần như đã sắp xếp
   + Hiệu năng kém với dữ liệu lớn.
  4. Merge Sort Algorithms (sắp xếp trộn):
   - Tuân theo tư tưởng: "Divide and Conquer" - Chia để trị
   - Ý tưởng:
    + 1. chia (Divide): mảng đầu vào được chia ra làm hai nửa.
    + 2. trị (Conquer): gọi đệ quy để sắp xếp từng nửa con.
    + 3. trộn (Merge): gộp hai mảng con đã được sắp xếp thành một mảng đã được sắp xếp.
  - Đặc điểm;
   + Time complexity:
    Best case: O(nlogn) - khi mảng đã được sắp xếp hoặc gần như đã sắp xếp.
    Agv: O(nlogn) - khi mảng có thứ tự ngẫu nhiên.
    Worst case: O(nlogn) - khi mảng được sắp xếp theo thứ tự ngược.
  - Ứng dung:
   + Sắp xếp các tập dữ liệu lớn (large datasets).
   + Sắp xếp ngoài (External sorting) — khi dữ liệu quá lớn để nạp hết vào bộ nhớ chính.
   + Được sử dụng để giải các bài toán như Inversion counting, Count Smaller on Right, và Surpasser Count.
   + Merge Sort và các biến thể của nó được dùng trong các thư viện lập trình. Biến thể TimSort được sử dụng trong Python, Java (Android) và Swift. 
     Lý do chính khiến nó được ưa chuộng cho các kiểu dữ liệu non-primitive là tính ổn định (stability) — điều mà QuickSort không có. 
     Trong Java, Arrays.sort() sử dụng QuickSort, còn Collections.sort() sử dụng MergeSort.
   + Là thuật toán được ưu tiên để sắp xếp danh sách liên kết (Linked list).
 5. Quick Sort Algorithms (sắp xếp nhanh):
  - Dựa trên phương pháp chia để trị (divide and Conquer).
  - Chọn một phần tử làm pivot (chốt) và phân hoạch (partition) mảng xung quanh phần tử đó bằng cách đặt pivot vào đúng vị trí của nó trong mảng đã sắp xếp (sorted array)
  - Ý tưởng: 
   + B1 - chọn pivot: chọn một phần tử trong mảng làm pivot (đầu, giữa, cuối).
   + B2 - Phân hoạch mảng (partition the array): xếp lại mảng xung quanh pivot, sau khi phân hoạch các phần tử < pivot ở bên trái, > pivot nằm bên phải, thu được chỉ số pivot.
   + B3 - gọi đệ quy (recursion): gọi đệ quy cho các mảng con.
   + B4 - base case: điều kiện để đệ quy dừng khi mảng con chỉ còn 1 phần tử.
  - Lựa chọn pivot: 
   + Luôn chọn phần tử đầu hoặc cuối: nhược điểm dễ rơi vào worst  khi mảng đã được sắp xếp sẵn.
   + Chọn phần tử ngẫu nhiên (Random element): không tạo ra mẫu cố định (pattern), tránh worst case.
   + Chọn phần tử trung vị (median): Cách tối ưu time complexity, nếu tìm được median trong thời gian tuyến tính, partition() chia mảng làm hai nửa bằng nhau.Tốn thời gian do tìm median có hằng số tg cao.
  - Partition Algorithms: 
    Quá trình quan trọng nhất trong quick sort là hàm partition().
    # 3 thuật toán phổ biến với độ phức tạp O(n)
   + Naive Partition (Phân vùng ngây thơ): tạo một bản sao, đưa các phần tử nhỏ hơn pivot vào trước sau đó các phần tử lớp hơn, cuối cùng sao chép mảng tạm vào mảng gốc.
   + Lomuto Partition (): đơn giản theo dõi chỉ số của phần tử nhỏ hơn và thực hiện swap khi cần thiết.
   + Hoare's Partion: thuật toán nhanh nhấ, duyệt mảng từ cả hai đầu, hoán đổi phần tử lớn ở bên trái với phẩn tử nhỏ ở bên phải cho đến khi mảng được phân hoạch.
  - Time complexity:
   + Best case: Ω(n log n) - pivot chia hai mảng thành 2 nửa bẳng nhau.
   + AGV case: θ(n log n) - pivot chia hai mảng bằng nhau, không nhất thiết cân đối hoàn toàn.
   + Worst case: O(n²)  - khi phần tử nhỏ nhất ỏ lớn nhất làm pivot (mảng đã được sắp xếp).
   






