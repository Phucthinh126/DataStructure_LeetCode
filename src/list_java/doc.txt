# Iterator
     * * dùng để duyệt (traverse) hoặc lặp (iterator) qua các phần tử của một collection theo từng phần tử 1
     * * duyệt các ptu theo chiều tiến (forward direction)
     * * xóa phần tử an toàn(safely) thông qua remote()
     * * áp dụng cho list, set, queue
 - syntax: Interface Iterator<E>
 # hàm chính:
    hasNext(): Trả về true nếu còn ít nhất một phần tử nữa trong dãy, ngược lại trả về false.

    next(): Trả về phần tử kế tiếp trong dãy.

    remove(): Xóa khỏi collection phần tử được trả về bởi lần gọi next() gần nhất.Nếu next() chưa được gọi, hoặc remove() đã được gọi sau lần next() gần nhất, phương thức này sẽ ném ra ngoại lệ IllegalStateException.

 # Emlement Iterator
  Iterator<ElementType> iter = colection.iterator();
  while (iter.hasNext()){
    ElementType variable = iter.next();
    loopBody // có thể sự dụng biến variable
  }

# list
 + IteratorList
 + ArrayList
 + LinkedList
 <---------------------->
  @ IteratorList:
  * Duyệt qua tất cả các loại list(Array list, linkedlist, vector, stack).
  * Hoạt động với các lớp cài đạt list
  * Hỗ trợ duyệt hai chiều tiến và lùi
  * Hỗ trợ create, read, update, delete
   - Con trỏ (cursor) nằm giữa phần tử trước (previous) và phần tử kế tiếp (next).
   - dạnh sách độ dài n có n+1 vị trí cursor
   - Duyệt tiến và lùi
    + Duyệt theo chiều tiến (forward direction iteration)
    .hasNext(): trả về true nếu danh sách còn phần tử để duyệt theo hướng tiến
    .next(): trả về phần tử kế tiếp của danh sách và di chuyển con trỏ tiến.
    .nextIndex(): trả về chỉ số index của phần tử sẽ được trả về khi gọi phương thức next().
    + Duyệt theo chiều lùi (backward direction itration)
    .hasPrevious(): trả về true nếu danh sách còn phần tử để duyệt theo hướng ngược
    .previous(): trả về phần tử trước đó của danh sách và lùi con trỏ một vị trí
    .previousIndex(): trả về chỉ số index của phần tử sẽ được trả về khi gọi phương thức previous(), listIterator đang ở đầu danh sách trả về -1.
   - remove(): xóa phần tử cuối cùng trả về bởi next() hoặc previous(), phải gọi sau next()/previous(), chỉ gọi 1 lần cho mỗi lần next()/previous()
    $ Lưu ý: ListIterator giống như con trỏ sau khi chạy 1 hàm sẽ đứng ở vị trí nào thì hàm thứ 2 sẽ chạy bắt đầu từ vị trí đó, do đó cần đưa con trỏ về đầu trước khi thực hiện hàm khác
  </--------------------->

  <---------------------->
  @ ArrayLisyt:
  * ArrayList mảng thay đổi kích thước thuộc gói java.util, có khả năng tự động mở hoạc thu nhỏ
   - Truy cập bằng chỉ mục: thông qua index
   - Cho phép trùng lặp: các phần tử lặp được phép xuất hiện trong danh sách
   - Giữ nguyên thứ tự chèn: phần tử được lưu trữ theo đúng thứ tự má chúng được thêm vào
   - Không đồng bộ: mặc định, ArrayList không thread-safe, cần đồng bộ hóa thủ công khi truy cập trong môi trườn đa luồng
  * ArrayList(class) ---implement---> list(Interface)---extends--->collection
  </------------------->

  <-------------------->
  @ linkedlist:
  #Basic:
  !! Singly Linked List:
   - Một singly linked list (danh sách liên kết đơn) là một cấu trúc dữ liệu cơ bản.
   - Gồm các node, mỗi node chứa một trường dữ liệu(data field) và một tham chiếu(reference) đến node tiếp theo trong danh sách liên kết.
   - Next của node cuối cùng là null, biểu thị kết thúc danh sách.
   - LinkedList: chèn(insertion) và xóa (deletion) hiệu quả
  * Node structure:
    1. Data(dữ liệu): trường chứa giá trị or đối tượng.
    2. Pointer to the next node (con trỏ đến node tiếp theo): tham chiếu liên kết node hiện tại với node kế tiếp.
    - liên kết tự động tạo thành chuỗi tuần tự
    HEAD → [data|next] → [data|next] → [data|next] → null
    - Không đi ngược
  --------------------------------------------------------
  ** Remove:
    - RemoveFirst(): remove(LAX)
     head → [LAX] → [MSP] → [ATL] → [BOS] → null
     |     ([LAX]) → [MSP] → [ATL] → [BOS] → null      (LAX đang được “bỏ ra”)
     |                 ↑
     |                head
     head → [MSP] → [ATL] → [BOS] → null     (LAX da bi xoa)
  ** Add First:
    - Danh sách ban đầu:
    ( head → [MSP] → [ATL] → [BOS] → null )
    1. Tạo node mới
    newest     head
      ↓         ↓
    [LAX] → ? [MSP] → [ATL] → [BOS] → null
    2. Gán newNode.next = head
    newest     head
      ↓         ↓
    [LAX] → [MSP] → [ATL] → [BOS] → null
    3. Cập nhật head = newNode
    head
      ↓
    [LAX] → [MSP] → [ATL] → [BOS] → null
  ------------------------------------------
  ** Add Last:
   - Danh sách ban đầu:
     [MSP] → [ATL] → [BOS] → null 
     |                ↑
     |               tail
    1. Tạo node mới
     [MSP] → [ATL] → [BOS] → null      [MIA] → null
     |                 ↑                  ↑
     |                tail              newest
    2. Gắn tail.next = newNode
     [MSP] → [ATL] → [BOS] → [MIA] → null
     |                 ↑       ↑
     |                tail   newest      
    3. Cập nhật tail = newNode
     [MSP] → [ATL] → [BOS] → [MIA] → null
     |                         ↑
     |                        tail
  !! Doubly LinkedList:
  
  



