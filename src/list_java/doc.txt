# Iterator
     * * dùng để duyệt (traverse) hoặc lặp (iterator) qua các phần tử của một collection theo từng phần tử 1
     * * duyệt các ptu theo chiều tiến (forward direction)
     * * xóa phần tử an toàn(safely) thông qua remote()
     * * áp dụng cho list, set, queue
 - syntax: Interface Iterator<E>
 # hàm chính:
    hasNext(): Trả về true nếu còn ít nhất một phần tử nữa trong dãy, ngược lại trả về false.

    next(): Trả về phần tử kế tiếp trong dãy.

    remove(): Xóa khỏi collection phần tử được trả về bởi lần gọi next() gần nhất.Nếu next() chưa được gọi, hoặc remove() đã được gọi sau lần next() gần nhất, phương thức này sẽ ném ra ngoại lệ IllegalStateException.

 # Emlement Iterator
  Iterator<ElementType> iter = colection.iterator();
  while (iter.hasNext()){
    ElementType variable = iter.next();
    loopBody // có thể sự dụng biến variable
  }

# list
 + IteratorList
 + ArrayList
 + LinkedList
 <---------------------->
  @ IteratorList:
  * Duyệt qua tất cả các loại list(Array list, linkedlist, vector, stack).
  * Hoạt động với các lớp cài đạt list
  * Hỗ trợ duyệt hai chiều tiến và lùi
  * Hỗ trợ create, read, update, delete
   - Con trỏ (cursor) nằm giữa phần tử trước (previous) và phần tử kế tiếp (next).
   - dạnh sách độ dài n có n+1 vị trí cursor
   - Duyệt tiến và lùi
    + Duyệt theo chiều tiến (forward direction iteration)
    .hasNext(): trả về true nếu danh sách còn phần tử để duyệt theo hướng tiến
    .next(): trả về phần tử kế tiếp của danh sách và di chuyển con trỏ tiến.
    .nextIndex(): trả về chỉ số index của phần tử sẽ được trả về khi gọi phương thức next().
    + Duyệt theo chiều lùi (backward direction itration)
    .hasPrevious(): trả về true nếu danh sách còn phần tử để duyệt theo hướng ngược
    .previous(): trả về phần tử trước đó của danh sách và lùi con trỏ một vị trí
    .previousIndex(): trả về chỉ số index của phần tử sẽ được trả về khi gọi phương thức previous(), listIterator đang ở đầu danh sách trả về -1.
   - remove(): xóa phần tử cuối cùng trả về bởi next() hoặc previous(), phải gọi sau next()/previous(), chỉ gọi 1 lần cho mỗi lần next()/previous()
    $ Lưu ý: ListIterator giống như con trỏ sau khi chạy 1 hàm sẽ đứng ở vị trí nào thì hàm thứ 2 sẽ chạy bắt đầu từ vị trí đó, do đó cần đưa con trỏ về đầu trước khi thực hiện hàm khác
  </--------------------->

  <---------------------->
  @ ArrayLisyt:
  * ArrayList mảng thay đổi kích thước thuộc gói java.util, có khả năng tự động mở hoạc thu nhỏ
   - Truy cập bằng chỉ mục: thông qua index
   - Cho phép trùng lặp: các phần tử lặp được phép xuất hiện trong danh sách
   - Giữ nguyên thứ tự chèn: phần tử được lưu trữ theo đúng thứ tự má chúng được thêm vào
   - Không đồng bộ: mặc định, ArrayList không thread-safe, cần đồng bộ hóa thủ công khi truy cập trong môi trườn đa luồng
  * ArrayList(class) ---implement---> list(Interface)---extends--->collection
  </------------------->

  <-------------------->
  @ linkedlist:
  #Basic:
  !! Singly Linked List:
   - Một singly linked list (danh sách liên kết đơn) là một cấu trúc dữ liệu cơ bản.
   - Gồm các node, mỗi node chứa một trường dữ liệu(data field) và một tham chiếu(reference) đến node tiếp theo trong danh sách liên kết.
   - Next của node cuối cùng là null, biểu thị kết thúc danh sách.
   - LinkedList: chèn(insertion) và xóa (deletion) hiệu quả
  * Node structure:
    1. Data(dữ liệu): trường chứa giá trị or đối tượng.
    2. Pointer to the next node (con trỏ đến node tiếp theo): tham chiếu liên kết node hiện tại với node kế tiếp.
    - liên kết tự động tạo thành chuỗi tuần tự
    HEAD → [data|next] → [data|next] → [data|next] → null
    - Không đi ngược
  --------------------------------------------------------
  ** Remove:
    - RemoveFirst(): remove(LAX)
     head → [LAX] → [MSP] → [ATL] → [BOS] → null
     |     ([LAX]) → [MSP] → [ATL] → [BOS] → null      (LAX đang được “bỏ ra”)
     |                 ↑
     |                head
     head → [MSP] → [ATL] → [BOS] → null     (LAX da bi xoa)
  ** Add First:
    - Danh sách ban đầu:
    ( head → [MSP] → [ATL] → [BOS] → null )
    1. Tạo node mới
    newest     head
      ↓         ↓
    [LAX] → ? [MSP] → [ATL] → [BOS] → null
    2. Gán newNode.next = head
    newest     head
      ↓         ↓
    [LAX] → [MSP] → [ATL] → [BOS] → null
    3. Cập nhật head = newNode
    head
      ↓
    [LAX] → [MSP] → [ATL] → [BOS] → null
  ------------------------------------------
  ** Add Last:
   - Danh sách ban đầu:
     [MSP] → [ATL] → [BOS] → null 
     |                ↑
     |               tail
    1. Tạo node mới
     [MSP] → [ATL] → [BOS] → null      [MIA] → null
     |                 ↑                  ↑
     |                tail              newest
    2. Gắn tail.next = newNode
     [MSP] → [ATL] → [BOS] → [MIA] → null
     |                 ↑       ↑
     |                tail   newest      
    3. Cập nhật tail = newNode
     [MSP] → [ATL] → [BOS] → [MIA] → null
     |                         ↑
     |                        tail
  --------------------------------------------------
  
  !! Doubly LinkedList:
   - Phức tạp hơn Singly LinkedList.
   - Cho phép duyệt danh sách hiệu quả theo cả hai hướng.
   - Mỗi Node chứa con trỏ đến node trước đó và con trỏ đến node tiếp theo.
     head                                                                        tail
      ↓                                                                            ↓
     null ← [prev|null | data=A | next→] ↔ [prev← | data=B | next→] ↔ [prev← | data=C | next|null] → null
   - Thao tác chèn và xóa nhanh chóng, dễ dàng,
  ** Biểu diễn linkedlist:
   1. Data: dữ liệu được lưu trong node
   2. A pointer to the next node (next): con trỏ trỏ đến node kế tiếp
   3. A pointer to the previous node (prev) – con trỏ trỏ đến node phía trước
  ** Tạo một Double Linked List:
   - Gồm 4 node:
    1. Tạo node head:
    2. Tạo node tiếp theo và liên kết với head
      head.next = new Node(data2)
      head.next.prev = head
    3. Tạo các node tiếp theo theo thứ tự tương tự
    4. Đảm bảo node cuối cùng có next == null
      tail.next = null
  -----------------------------------------------------------
 
  !! Circular Linked List
   - Circular có node cuối cùng trỏ ngược lại node đầu tiên, tạo thành một vòng khép kính.
   ** Cấu trúc:
    - Tất cả các node liên kết với thành một vòng, cho phép duyệt liên tục mà không bao giờ gặp null.
     head                     tail
      ↓                       ↓
    [LAX] → [MSP] → [ATL] → [BOS]
    ↑                       │
    |_______________________|
    - Node cuối -> node đầu
   ** Các loại circular lineked list:
    1. Singly Circular Linked List - danh sách liên kết đơn dạng vòng.
     + Mỗi node chỉ có một con trỏ duy nhất "next", next của node cuối trỏ đến vào node đầu tạo thành vòng tròn.
     + Chỉ có thể di chuyển qua danh sách theo một chiều hướng duy nhất.

     head                             tail
      ↓                               ↓
     [data|next] → [data|next] → [data|next]
      ↑________________________________|

    2. Doubly Circular Linked List - danh sách liên kết đôi dạng vòng.
     + Mỗi node có hai con trỏ: prev và next.
      . Con trỏ prev trỏ đến node trước.
      . Con trỏ next đến node kế tiếp.
     + Node cuối cùng không chỉ trỏ đến node đầu tiên mà node đầu tiên cũng trỏ trở lại node cuối cùng.
     
     |              __________________________________________
     |              |                                        ↓
      head → [prev|data|next] ↔  [prev|data|next] ↔  [prev|data|next] ← tail
     |              ↑________________________________________|

  
  



